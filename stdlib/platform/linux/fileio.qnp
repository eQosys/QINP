\\ QINP Standard Library
\\ File Input/Output - Linux Specific

import "__syscall.qnp"
import "__ioctl.qnp"

import "../../string.qnp"
import "../../error.qnp"

space std:
	define __OPEN_READONLY 00
	define __OPEN_WRITEONLY 01
	define __OPEN_READWRITE 02
	define __OPEN_CREATE 0100
	define __OPEN_TRUNCATE 01000



defer
space std:
	pack File!:
		pass

	fn<File*> fopen(u8 const* filename, u8 const* modeStr) nodiscard!:
		if !filename || !modeStr:
			error.set(error.ID.InvalidArgument)
			return null

		var<i32> flags
		var<i32> mode = 0
		if strcmp(modeStr, "r") == 0:
			flags = __OPEN_READONLY
		elif strcmp(modeStr, "w") == 0:
			flags = __OPEN_WRITEONLY | __OPEN_CREATE | __OPEN_TRUNCATE
			mode = 0644
		elif strcmp(modeStr, "rw") == 0:
			flags = __OPEN_READWRITE | __OPEN_CREATE | __OPEN_TRUNCATE
			mode = 0644
		else:
			error.set(error.ID.InvalidArgument)
			return null

		const fd = __syscall(__SYS_OPEN, filename, flags, mode)

		if fd < 0:
			error.set(error.ID.FileIO)
			return null
		
		return (File*)fd

	fn<u64> fread(File* pFile, void* dest, u64 num)!:
		if !pFile || !dest:
			error.set(error.ID.InvalidArgument)
			return -1

		return __syscall(__SYS_READ, pFile, dest, num)

	fn<u64> fwrite(File* pFile, void const* src, u64 num)!:
		if !pFile || !src:
			error.set(error.ID.InvalidArgument)
			return -1

		return __syscall(__SYS_WRITE, pFile, src, num)

	fn<u64> fseek(File* pFile, u64 offset, Seek origin)!:
		if !pFile:
			error.set(error.ID.InvalidArgument)
			return -1

		var<u64> uOrigin

		if origin == Seek.Begin: uOrigin = 0
		elif origin == Seek.Current: uOrigin = 1
		elif origin == Seek.End: uOrigin = 2
		else:
			error.set(error.ID.InvalidArgument)
			return -1

		return __syscall(__SYS_LSEEK, pFile, offset, uOrigin)

	fn<> fclose(File* pFile)!:
		if !pFile:
			error.set(error.ID.InvalidArgument)
			return

		__syscall(__SYS_CLOSE, pFile)