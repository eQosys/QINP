\\ QINP Standard Library
\\ Standard Input/Output

import "math.qnp"
import "error.qnp"
import "string.qnp"
import "limits.qnp"

space std:
	enum __PrintFmtMod_Type:
		Default
		Int_Bin, Int_Oct, Int_Dec, Int_Hex, Int_Chr,
		Str
	
	enum __PrintFmtMod_Alignment:
		None, Left, Right
	
	\\ Pack used to store a format modifier for printing
	pack __PrintFmtMod...

	\\ Print the first num chars of a string to stdout
	\\ @param str The string to print
	\\ @param len The length of the string to print
	\\ @return The number of characters printed. Negative on error.
	fn<i32> printn(u8 const* str, u64 num)...		\\ Platform dependent implementation

	\\ Print a null-terminated string to stdout
	\\ @param str The null-terminated string to print
	\\ @return The number of characters printed. Negative on error.
	fn<i32> print(u8 const* str)...

	\\ Print a single character to stdout
	\\ @param char The character to print
	\\ @return The number of characters printed, negative on error.
	fn<i32> print(u8 char)...

	\\ Print a boolean value to stdout
	\\ @param val The boolean to print (printed as "true" or "false")
	\\ @return The number of characters printed, negative on error.
	fn<i32> print(bool val)...

	\\ Print a base-10 value with any other integral type to stdout
	\\ @param num The integer to print
	\\ @return The number of characters printed. Negative on error.
	fn<i32> print(?T val)...

	\\ Format a string and print it to stdout
	\\ @param format Format string
	\\ @param val The first argument placed in the string
	\\ @return The number of characters printed, negative on error.
	fn<i32> print(u8 const* format, ?T val)...

	\\ Format a string and print it to stdout
	\\ @param format Format string
	\\ @param val The first argument placed in the string
	\\ @param ... The remaining arguments placed in the string
	\\ @return The number of characters printed, negative on error.
	fn<i32> print(u8 const* format, ?T val, ...)...

	\\ Internal function to print a formatted string to stdout
	\\ @param pFormat A pointer to the format string
	\\ @param val The value to place in the string
	\\ @return The number of characters printed, negative on error.
	fn<i32> __printf(u8 const** pFormat, ?T val)...

	\\ Internal function to extract the format modifier from the format string
	\\ @param format Format string
	\\ @param pMod Pointer to a format modifier pack to store the info in
	\\ @return Number of characters read (Length of the format modifier)
	fn<i32> __extractFmtMod(u8 const* format, __PrintFmtMod* pMod)...

	\\ Internal function to print a value using a specified format modifier
	\\ @param val The value to print
	\\ @param mod The format modifier to use
	\\ @return The number of characters printed, negative on error.
	fn<i32> __printMod(?T val, __PrintFmtMod const* pMod)...

	\\ Internal function to print a value using a specified format modifier
	\\ @param str The string to print
	\\ @param mod The format modifier to use
	\\ @return The number of characters printed, negative on error.
	fn<i32> __printMod(u8 const* str, __PrintFmtMod const* pMod)...

	\\ Internal function to print a value using a specified format modifier
	\\ @param val The value to print
	\\ @param mod The format modifier to use
	\\ @return The number of characters printed, negative on error.
	fn<i32> __printMod(bool val, __PrintFmtMod const* pMod)...

	\\ Internal function to print len characters of a string or less.
	\\ @param str The string to print
	\\ @param len The maximum number of characters to print
	\\ @return The number of characters printed, negative on error.
	fn<i32> __printMaxLen(u8 const* str, u64 len)...

	fn<i32> __printPadding(u8 ch, u64 num)...

	fn<> __initFmtMod(__PrintFmtMod* pMod)...

	\\ Prints a newline to stdout
	\\ @return Positive on success, negative on error.
	fn<i32> println()...

	\\ Same as print but appends a newline
	\\ @param val The value to print (passed to appropriate print function)
	\\ @return The number of characters printed, negative on error.
	fn<i32> println(?T val)...

	\\ Same as print but appends a newline
	\\ @param format Format string
	\\ @param ... The remaining values to print (passed to appropriate print function)
	\\ @return The number of characters printed, negative on error.
	fn<i32> println(u8 const* format, ...)...

	\\ Reads a character from stdin
	\\ @return The character read
	fn<u8> getchar() nodiscard...

	\\ Reads a specified number of characters from stdin and appends a null character
	\\ @param dest The destination buffer (Minimum buffer size: [num] + 1)
	\\ @param num The number of characters to read
	\\ @return Number of characters read, negative on error
	fn<i32> scann(u8* dest, u64 num)...		\\ Platform dependent implementation



defer
space std:
	pack __PrintFmtMod!:
		var<__PrintFmtMod_Type> type
		var<u64> strLen
		var<__PrintFmtMod_Alignment> alignment
		var<i64> fieldWidth
		var<u8> fillChar

	fn<i32> print(u8 const* str)!:
		if !str:
			error.set(error.ID.InvalidArgument)
			return -1

		return printn(str, strlen(str))

	fn<i32> print(u8 char)!:
		return printn(&char, 1)

	fn<i32> print(bool val)!:
		return print(val ? "true" : "false")

	fn<i32> print(?T val)!:
		const<u8[32]> buf
		return print(itos(val, buf, 10))

	fn<i32> print(u8 const* format, ?T val)!:
		if !format:
			error.set(error.ID.InvalidArgument)
			return -1

		var<i32> n1
		var<i32> n2

		if (n1 = __printf(&format, val)) < 0: return -1
		if (n2 = print(format)) < 0: return -1
		return n1 + n2

	fn<i32> print(u8 const* format, ?T val, ...)!:
		if !format:
			error.set(error.ID.InvalidArgument)
			return -1

		var<i32> n1
		var<i32> n2

		if (n1 = __printf(&format, val)) < 0: return -1
		if (n2 = print(format, ...)) < 0: return -1
		return n1 + n2

	fn<i32> __printf(u8 const** pFormat, ?T val)!:
		if !pFormat:
			error.set(error.ID.InvalidArgument)
			return -1

		const format = *pFormat
		const dropPos = strchr(format, '%')

		var<u64> nCharsToPrint
		var<u64> modChars
		var<__PrintFmtMod> mod
		__initFmtMod(&mod)

		if dropPos:
			nCharsToPrint = (u64)(dropPos - format)
			modChars = __extractFmtMod(format + nCharsToPrint, &mod)
		else:
			nCharsToPrint = strlen(format)
			modChars = 0

		*pFormat = format + nCharsToPrint + modChars
		
		var<i32> n1
		var<i32> n2
		var<i32> nPadding = 0

		if (n1 = printn(format, nCharsToPrint)) < 0: return -1

		if mod.alignment == __PrintFmtMod_Alignment.Left:
			if (n2 = __printMod(val, &mod)) < 0: return -1
			if (nPadding = __printPadding(mod.fillChar, mod.fieldWidth - n2)) < 0: return -1
		elif mod.alignment == __PrintFmtMod_Alignment.Right:
			\\var pl = printLen(...)
			\\if (nPadding = __printpadding(mod.fillChar, mod.fieldWidth - pl)) < 0: return -1
			if (n2 = __printMod(val, &mod)) < 0: return -1
		else:
			if (n2 = __printMod(val, &mod)) < 0: return -1

		return n1 + n2 + nPadding

	fn<i32> __extractFmtMod(u8 const* format, __PrintFmtMod* pMod)!:		
		if !format || !pMod:
			return 0

		if *format++ != '%':
			return 0

		var nChars = 1

		while true:
			var ch = *format++
			if ch == 'b':
				pMod->type = __PrintFmtMod_Type.Int_Bin
				++nChars 
			elif ch == 'o':
				pMod->type = __PrintFmtMod_Type.Int_Oct
				++nChars
			elif ch == 'd':
				pMod->type = __PrintFmtMod_Type.Int_Dec
				++nChars 
			elif ch == 'x':
				pMod->type = __PrintFmtMod_Type.Int_Hex
				++nChars 
			elif ch == 'c':
				pMod->type = __PrintFmtMod_Type.Int_Chr
				++nChars 
			elif ch == 's':
				pMod->type = __PrintFmtMod_Type.Str
				var<u8 const*> pNext
				pMod->strLen = stoi(format, &pNext, 10)
				if pNext == format:
					pMod->strLen = limits.I64_MAX
				nChars += 1 + (u64)(pNext - format)
				format = pNext
			elif ch == '-':
				pMod->alignment = __PrintFmtMod_Alignment.Left
				var<u8 const*> pNext
				pMod->fieldWidth = stoi(format, &pNext, 10)
				nChars += 1 + (u64)(pNext - format)
				format = pNext
			elif ch == '+':
				pMod->alignment = __PrintFmtMod_Alignment.Right
				var<u8 const*> pNext
				pMod->fieldWidth = stoi(format, &pNext, 10)
				nChars += 1 + (u64)(pNext - format)
				format = pNext
			elif ch == 'f':
				pMod->fillChar = *format++
			else:
				break

		return nChars

	fn<i32> __printMod(?T val, __PrintFmtMod const* pMod)!:
		var<u8[32]> buf
		if pMod->type == __PrintFmtMod_Type.Int_Bin:
			return print(itos(val, buf, 2))
		if pMod->type == __PrintFmtMod_Type.Int_Oct:
			return print(itos(val, buf, 8))
		if pMod->type == __PrintFmtMod_Type.Int_Dec:
			return print(itos(val, buf, 10))
		if pMod->type == __PrintFmtMod_Type.Int_Hex:
			return print(itos(val, buf, 16))
		if pMod->type == __PrintFmtMod_Type.Int_Chr:
			return print((u8)val)
		return print(val)

	fn<i32> __printMod(u8 const* str, __PrintFmtMod const* pMod)!:
		if pMod->type == __PrintFmtMod_Type.Str:
			return __printMaxLen(str, pMod->strLen)
		return print(str)

	fn<i32> __printMod(bool val, __PrintFmtMod const* pMod)!:
		\\ TODO: Implementation
		return print(val)

	fn<i32> __printMaxLen(u8 const* str, u64 len)!:
		if !str:
			error.set(error.ID.InvalidArgument)
			return -1
		
		return printn(str, min(strlen(str), len))

	fn<i32> __printPadding(u8 ch, u64 num)!:
		var<u64> i = 0
		while i++ < num:
			if print(ch) < 0: return -1
		return num

	fn<> __initFmtMod(__PrintFmtMod* pMod)!:
		pMod->type = __PrintFmtMod_Type.Default
		pMod->strLen = -1
		pMod->alignment = __PrintFmtMod_Alignment.None
		pMod->fieldWidth = -1
		pMod->fillChar = ' '

	fn<i32> println()!:
		return print('\n')

	fn<i32> println(?T val)!:
		var<i32> n
		if (n = print(val)) < 0: return -1
		if println() < 0: return -1
		return n + 1

	fn<i32> println(u8 const* format, ...)!:
		var<i32> n
		if (n = print(format, ...)) < 0: return -1
		if println() < 0: return -1
		return n + 1

	fn<u8> getchar() nodiscard!:
		const<u8[2]> buff
		scann(buff, 1)
		return *buff

import "platform/{platform}/stdio.qnp"