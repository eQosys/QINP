\\ QINP Standard Library
\\ Algorithms

import "error.qnp"

space std:
	\\ Function signature for a comparison function.
	define FN_COMPARE fn<bool>(void const*, void const*)

	\\ Function signature for a swap function.
	define FN_SWAP fn<>(void*, void*)

	\\ Function signature for a random number generator.
	define FN_RANDOM fn<u64>()

	\\ Macro to define a lambda function that swaps two elements by copying them per byte.
	\\ @param size The size of the elements.
	define LMBD_SWAP(size) lambda<void>(void* a, void* b): std.swap(a, b, size); \\ TODO: Use `.std.swap` instead of `std.swap` (Add leading dot)

	\\ Macro to define a lambda function that swaps two elements of the given type by copying them per byte.
	\\ @param type The type of the elements.
	define LMBD_SWAP_DT(type) std.LMBD_SWAP(sizeof(type))

	\\ Macro to define a lambda function that compares two elements according to the given check.
	\\ @param check The check to use. (e.g. *(i64*)a < *(i64*)b)
	define LMBD_COMPARE(check) lambda<bool>(void const* a, void const* b): return check;

	\\ Macro to define a lambda function that compares two elements of the given type using the `<` operator.
	\\ @param type The type of the elements.
	define LMBD_COMPARE_DT(type) std.LMBD_COMPARE(*(type const*)a < *(type const*)b)

	\\ Sorts an array of elements.
	\\ @param array The array to sort.
	\\ @param count The number of elements in the array.
	\\ @param elemSize The size of each element.
	\\ @param compare A function that compares two elements. (Ascending: true if a < b)
	\\ @param swap A function that swaps two elements.
	\\ @return The sorted array.
	fn<void*> sort(void* array, u64 count, u64 elemSize, FN_COMPARE compare, FN_SWAP swap)...

	\\ Shuffles an array of elements.
	\\ @param array The array to shuffle.
	\\ @param count The number of elements in the array.
	\\ @param elemSize The size of each element.
	\\ @param swap A function that swaps two elements.
	\\ @param random A function that returns a random number.
	fn<> shuffle(void* array, u64 count, u64 elemSize, FN_SWAP swap, FN_RANDOM random)...

	\\ Swaps the content of two arrays.
	\\ @param a The first array.
	\\ @param b The second array.
	\\ @param size The size of each array.
	fn<> swap(void* a, void* b, u64 size)...

	\\ Returns the index of any elemnt in an array that matches the given key.
	\\ @param key The key to search for.
	\\ @param array The array to search. (Must be sorted in the same order as compare would sort the array)
	\\ @param count The number of elements in the array.
	\\ @param elemSize The size of each element.
	\\ @param compare A function that compares two elements. (Ascending: true if a < b)
	\\ @return The index of the element that matches the key, or -1 if no element matches the key.
	fn<u64> bsearch(void const* key, void const* array, u64 count, u64 elemSize, FN_COMPARE compare)...



defer
space std:
	fn<void*> sort(void* array, u64 count, u64 elemSize, FN_COMPARE compare, FN_SWAP swap)!:	
		if !array || !compare || !swap:
			error.set(error.ID.InvalidArgument)
			return null
		
		var<u64> end = count

		while end > 0:
			var<u64> i = 0
			while i + 1 < end:
				if compare(array + (i + 1) * elemSize, array + i * elemSize):
					swap(array + (i + 1) * elemSize, array + i * elemSize)
				++i
			--end

		return array

	fn<> shuffle(void* array, u64 count, u64 elemSize, FN_SWAP swap, FN_RANDOM random)!:
		if !array || !swap || !random:
			error.set(error.ID.InvalidArgument)
			return

		var<u64> i = -1
		while ++i < count:
			std.swap(array + i * elemSize, array + random() % count * elemSize, elemSize)

	fn<> swap(void* a, void* b, u64 size)!:
		if !a || !b:
			error.set(error.ID.InvalidArgument)
			return

		var<u8> temp
		var<u64> i = -1
		while ++i < size:
			temp = ((u8*)a)[i]
			((u8*)a)[i] = ((u8*)b)[i]
			((u8*)b)[i] = temp

	fn<u64> bsearch(void const* key, void const* array, u64 count, u64 elemSize, FN_COMPARE compare)!:
		if !key || !array || !compare:
			error.set(error.ID.InvalidArgument)
			return -1

		var<u64> start = 0
		var<u64> end = count
		var<u64> mid

		while start < end:
			mid = (start + end) / 2
			if compare(key, array + mid * elemSize):
				end = mid
			elif compare(array + mid * elemSize, key):
				start = mid + 1
			else:
				return mid
		
		return -1