\\ QINP Standard Library
\\ List

import "memory.qnp"
import "error.qnp"
import "iterator.qnp"

space std:
	pack List:
		pack Node:
			var<Node*> prev
			var<Node*> next
			var<void*> data

		var<Node*> m_first
		var<Node*> m_last

		define FN_DATA_AFTER_REMOVE fn<void> (void*)

		fn<bool> __new__(List* self)...

		fn<> __delete__(List* self)...

		fn<> clear(List* self)...

		fn<.std.List.Node*> push_back(List* self, ?T data)...

		fn<.std.List.Node*> push_front(List* self, ?T data)...

		fn<?T> pop_back(List* self)...

		fn<?T> pop_front(List* self)...

		fn<.std.List.Node*> insert_before(List* self, Node* node, ?T data)...

		fn<.std.List.Node*> insert_after(List* self, Node* node, ?T data)...

		fn<?T> remove(List* self, Node* node)...

		fn<?T> remove_before(List* self, Node* node)...

		fn<?T> remove_after(List* self, Node* node)...

		fn<u64> length(List const* self)...

		fn<bool> empty(List const* self)...

		fn<.std.List.Node*> __alloc_node(Node* prev, Node* next, void* data)...

		fn<> __free_node(Node* node)...

		fn<.std.Iterator*> iterator(List* self)...

		fn<void> delete_iterator(List const* self, Iterator* it)...


	space List_old:
		\\ A single node in a list.
		pack Node:
			var<Node*> next
			var<void*> data

		\\ Creates a new node with the given data.
		\\ @param data The data to store in the node.
		\\ @return The new node.
		fn<Node*> create(void* data)...

		\\ Destroys the given node.
		\\ @param node The node to destroy.
		fn<> destroy(Node* node)...
	
		\\ Creates a new node with the given data and append it to the list.
		\\ @param list The list to append to. If null, a new list will be created.
		\\ @param data The data to append.
		\\ @return The new node.
		fn<Node*> append(Node* list, void* data)...

		\\ Appends the given node to the list.
		\\ @param list The list to append to.
		\\ @param node The node to append.
		\\ @return The appended node.
		fn<Node*> append(Node* list, Node* node)...

		\\ Inserts a new node with the given data after the given node.
		\\ @param node The node to insert after. If null, a new list will be created.
		\\ @param data The data to insert.
		\\ @return The new node.
		fn<Node*> insert(Node* node, void* data)...

		\\ Inserts the given node (of a list) after the given node of a list.
		\\ @param list The node to insert after.
		\\ @param node The node to insert.
		\\ @return The inserted node.
		fn<Node*> insert(Node* list, Node* node)...

		\\ Removes and destroys the given node from the list.
		\\ @param list The list to remove from.
		\\ @param node The node to remove.
		\\ @return The node after the removed node. If the removed node was the last node, null is returned.
		fn<Node*> remove(Node* list, Node* node)...

		\\ Returns the length of the given list.
		\\ @param list The list to get the length of.
		\\ @return The length of the list.
		fn<u64> length(Node const* list)...

		\\ Returns the last node of the given list.
		\\ @param list The list to get the last node of.
		\\ @return The last node of the list.
		fn<Node*> last(Node* list)...



defer
space std:
	fn<bool> List.__new__(List* self)!:
		self->m_first = null
		self->m_last = null
		return true

	fn<> List.__delete__(List* self)!:
		clear(self)
	
	fn<> List.clear(List* self)!:
		while !self->empty():
			self->pop_front({void*})

	fn<.std.List.Node*> List.push_back(List* self, ?T data)!:
		var<Node*> node = __alloc_node(self->m_last, null, data)

		if self->m_last:
			self->m_last->next = node

		self->m_last = node

		if !self->m_first:
			self->m_first = node

		return node

	fn<.std.List.Node*> List.push_front(List* self, ?T data)!:
		var<Node*> node = __alloc_node(null, self->m_first, data)

		if self->m_first:
			self->m_first->prev = node

		self->m_first = node

		if !self->m_last:
			self->m_last = node

		return node

	fn<?T> List.pop_back(List* self)!:
		if self->empty():
			error.set(error.ID.InvalidArgument)
			return null

		var<Node*> node = self->m_last
		var data = (T)node->data
		self->m_last = node->prev

		if self->m_last:
			self->m_last->next = null
		else:
			self->m_first = null

		__free_node(node)

		return data

	fn<?T> List.pop_front(List* self)!:
		if self->empty():
			error.set(error.ID.InvalidArgument)
			return null

		var<Node*> node = self->m_first
		var data = (T)node->data
		self->m_first = node->next

		if self->m_first:
			self->m_first->prev = null
		else:
			self->m_last = null

		__free_node(node)

		return data

	fn<.std.List.Node*> List.insert_before(List* self, Node* node, ?T data)!:
		if !node:
			error.set(error.ID.InvalidArgument)
			return null

		var<Node*> newNode = __alloc_node(node->prev, node, data)

		if node->prev:
			node->prev->next = newNode
		else:
			self->m_first = newNode

		node->prev = newNode

		return newNode

	fn<.std.List.Node*> List.insert_after(List* self, Node* node, ?T data)!:
		if !node:
			error.set(error.ID.InvalidArgument)
			return null

		var<Node*> newNode = __alloc_node(node, node->next, data)

		if node->next:
			node->next->prev = newNode
		else:
			self->m_last = newNode

		node->next = newNode

		return newNode

	fn<?T> List.remove(List* self, Node* node)!:
		if !node:
			error.set(error.ID.InvalidArgument)
			return null
		
		var data = (T)node->data

		if node->prev:
			node->prev->next = node->next
		else:
			self->m_first = node->next

		if node->next:
			node->next->prev = node->prev
		else:
			self->m_last = node->prev

		__free_node(node)

		return data

	fn<?T> List.remove_before(List* self, Node* node)!:
		if !node:
			error.set(error.ID.InvalidArgument)
			return null

		return remove(self, node->prev)

	fn<?T> List.remove_after(List* self, Node* node)!:
		if !node:
			error.set(error.ID.InvalidArgument)
			return null

		return remove(self, node->next)

	fn<u64> List.length(List const* self)!:
		var<u64> length = 0
		var<Node*> node = self->m_first

		while node:
			++length
			node = node->next

		return length

	fn<bool> List.empty(List const* self)!:
		return self->m_first == null

	fn<.std.List.Node*> List.__alloc_node(Node* prev, Node* next, void* data)!:
		var<Node*> node = (Node*)std.malloc(sizeof(Node))
		node->prev = prev
		node->next = next
		node->data = data
		return node

	fn<> List.__free_node(Node* node)!:
		std.free(node)

	fn<.std.Iterator*> List.iterator(List* self)!:
		return new( \
			Iterator, \
			self->m_first, \
			lambda<bool>(void const* node): return node != null;, \
			lambda<void*>(void* node): return ((.std.List.Node*)node)->data;, \
			lambda<void*>(void* node): return ((.std.List.Node*)node)->next; \
		)

	fn<> List.delete_iterator(List const* self, Iterator* iterator)!:
		delete(iterator)



	space List_old:
		fn<Node*> create(void* data)!:
			var<Node*> node = (Node*)std.malloc(sizeof(Node))
			node->next = null
			node->data = data
			return node

		fn<> destroy(Node* node)!:
			if !node:
				error.set(error.ID.InvalidArgument)
				return

			std.free(node)

		fn<Node*> append(Node* list, void* data)!:
			return append(list, create(data))

		fn<Node*> append(Node* list, Node* node)!:
			list = last(list)
			if list == null || node == null:
				return node
			list->next = node
			return node

		fn<Node*> insert(Node* node, void* data)!:
			return insert(node, create(data))

		fn<Node*> insert(Node* list, Node* node)!:
			if list == null || node == null:
				return node
			
			last(node)->next = list->next
			list->next = node
			return node

		fn<Node*> remove(Node* list, Node* node)!:
			if list == null || node == null:
				return null

			if list == node:
				var next = list->next
				destroy(list)
				return next

			while list->next != null:
				if list->next == node:
					var next = list->next->next
					list->next->next = null
					destroy(list->next)
					list->next = next
					return next
				list = list->next
			
			return null

		fn<u64> length(Node const* list)!:
			var<u64> length = 0
			while list != null:
				++length
				list = list->next
			return length

		fn<Node*> last(Node* list)!:
			if list == null:
				return null

			while list->next != null:
				list = list->next
			return list